<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <!-- Viewportを標準に戻し、UIサイズを確保 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>MATRIX DEFENDER: ABSOLUTE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&family=Share+Tech+Mono&display=swap');

        :root {
            --primary: #00ffcc;
            --secondary: #0088ff;
            --danger: #ff3366;
            --warning: #ffcc00;
            --bg: #050505;
        }

        html, body {
            width: 100%; height: 100%;
            margin: 0; padding: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Rajdhani', sans-serif;
            color: var(--primary);
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            position: fixed;
        }

        .vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 40%, rgba(0,0,0,0.9) 100%);
            pointer-events: none; z-index: 10;
        }
        .scanlines {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.1) 0px, rgba(0,0,0,0.1) 1px, transparent 1px, transparent 2px);
            pointer-events: none; z-index: 11;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 20; display: none;
        }

        /* HUDパネル */
        .hud-panel {
            position: absolute;
            background: rgba(0, 20, 40, 0.7);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(0, 255, 204, 0.3);
            padding: 5px 15px;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.1);
        }
        .hud-panel::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary), transparent);
        }

        #score-box { top: 20px; left: 20px; }
        .label { font-family: 'Share Tech Mono'; font-size: 11px; letter-spacing: 2px; color: var(--secondary); display: block; margin-bottom: -2px; }
        .value { font-size: 28px; font-weight: 700; line-height: 1.1; text-shadow: 0 0 10px var(--primary); }

        #wave-box { top: 20px; right: 20px; text-align: right; border-color: var(--warning); }
        #wave-box .label { color: var(--warning); }
        #ui-wave { color: var(--warning); text-shadow: 0 0 10px var(--warning); }

        #heat-container {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 200px; text-align: center;
        }
        .heat-bar-bg {
            width: 100%; height: 6px; background: rgba(255,255,255,0.1);
            border-radius: 3px; overflow: hidden; margin-top: 5px;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #heat-fill {
            width: 0%; height: 100%; 
            background: linear-gradient(90deg, var(--secondary), var(--warning), var(--danger));
            transition: width 0.1s linear;
            box-shadow: 0 0 10px var(--danger);
        }

        /* EMPボタン - UIは標準サイズに戻す */
        #emp-btn {
            position: absolute; bottom: 50px; right: 20px;
            width: 80px; height: 80px;
            border-radius: 50%;
            background: rgba(0, 10, 0, 0.6);
            border: 2px solid rgba(255,255,255,0.1);
            pointer-events: auto;
            display: flex; align-items: center; justify-content: center; flex-direction: column;
            color: rgba(255,255,255,0.3); font-size: 11px; font-weight: bold;
            transition: all 0.3s; cursor: pointer;
            backdrop-filter: blur(5px);
            touch-action: manipulation;
        }
        #emp-btn.ready {
            border-color: var(--secondary); color: #000; background: var(--secondary);
            box-shadow: 0 0 20px var(--secondary), inset 0 0 10px rgba(255,255,255,0.5);
            animation: pulse-btn 1s infinite alternate;
        }
        #emp-btn:active { transform: scale(0.95); }

        #alert-msg {
            position: absolute; top: 40%; width: 100%; text-align: center; font-size: 24px;
            color: var(--danger); font-weight: 700; text-shadow: 0 0 20px var(--danger);
            display: none; letter-spacing: 3px; animation: flash-text 0.15s infinite;
            background: rgba(0,0,0,0.3); padding: 5px 0;
        }

        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(3, 3, 5, 0.9);
            backdrop-filter: blur(10px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; pointer-events: auto;
            padding: 20px; box-sizing: border-box;
        }
        h1.title {
            font-size: clamp(32px, 10vw, 80px);
            margin: 0 0 20px 0; text-align: center; line-height: 0.9;
            background: linear-gradient(to bottom, #fff, var(--primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px var(--primary)); letter-spacing: 3px;
            width: 100%; word-break: break-word;
        }
        
        .btn {
            background: rgba(0,0,0,0.5); color: #fff;
            border: 2px solid var(--primary);
            padding: 15px 40px;
            font-size: 20px;
            font-family: 'Share Tech Mono'; letter-spacing: 2px;
            cursor: pointer; text-transform: uppercase;
            position: relative; overflow: hidden;
            transition: 0.2s;
            box-shadow: 0 0 15px rgba(0,255,204,0.2);
            touch-action: manipulation;
            user-select: none;
            z-index: 101;
            white-space: nowrap;
        }
        .btn:active { background: var(--primary); color: #000; transform: scale(0.96); }

        /* Tips Box Design */
        .tips-box {
            margin-top: 25px;
            padding: 15px;
            background: rgba(0, 20, 40, 0.6);
            border: 1px solid rgba(0, 255, 204, 0.3);
            border-left: 3px solid var(--primary);
            width: 100%;
            max-width: 350px;
            font-size: 13px;
            line-height: 1.6;
            color: #ccc;
            text-align: left;
            box-sizing: border-box;
        }
        .tips-title {
            color: var(--primary);
            font-weight: bold;
            border-bottom: 1px solid rgba(0, 255, 204, 0.2);
            margin-bottom: 8px;
            padding-bottom: 4px;
            letter-spacing: 1px;
            font-size: 15px;
        }
        .tips-row { display: flex; align-items: center; margin-bottom: 6px; }
        .key-icon {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 2px 6px; border-radius: 3px;
            color: #fff; font-family: 'Share Tech Mono'; margin-right: 8px;
            font-size: 11px; min-width: 40px; text-align: center;
        }
        .hl-warn { color: var(--danger); font-weight: bold; }
        .hl-emp { color: var(--secondary); font-weight: bold; }

        @keyframes pulse-btn { from { box-shadow: 0 0 15px var(--secondary); } to { box-shadow: 0 0 30px var(--secondary); } }
        @keyframes flash-text { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
    </style>
</head>
<body>

    <div class="vignette"></div>
    <div class="scanlines"></div>

    <!-- スタート画面 -->
    <div id="screen-start" class="screen">
        <h1 class="title">MATRIX<br>DEFENDER<br><span style="font-size:0.5em; letter-spacing:5px; color:var(--secondary)">ABSOLUTE</span></h1>
        
        <button id="btn-start" class="btn">SYSTEM BOOT</button>
        
        <div class="tips-box">
            <div class="tips-title">MISSION BRIEFING</div>
            <div class="tips-row">
                <span class="key-icon">TAP</span>
                <span>画面タップで迎撃ビーム発射</span>
            </div>
            <div class="tips-row">
                <span class="key-icon" style="color:var(--danger); border-color:var(--danger);">HEAT</span>
                <span>連射しすぎると<span class="hl-warn">オーバーヒート</span></span>
            </div>
            <div class="tips-row">
                <span class="key-icon" style="color:var(--secondary); border-color:var(--secondary);">EMP</span>
                <span>ゲージMAXで<span class="hl-emp">全画面攻撃</span></span>
            </div>
        </div>

        <div style="font-size:12px; color:#555; margin-top:20px; letter-spacing:1px;">TOUCH INTERFACE READY</div>
    </div>

    <!-- ゲームオーバー画面 -->
    <div id="screen-over" class="screen" style="display:none;">
        <h1 class="title" style="background:linear-gradient(to bottom, #fff, var(--danger)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; filter:drop-shadow(0 0 20px var(--danger));">CRITICAL<br>ERROR</h1>
        
        <div style="display:flex; flex-direction:column; align-items:center; gap:20px; margin-bottom:40px;">
            <div style="text-align:center;">
                <p style="color:#aaa; font-size:14px; letter-spacing:2px; margin-bottom:5px;">FINAL SCORE</p>
                <div id="final-score" style="font-size:52px; color:#fff; font-weight:700; line-height:1; text-shadow:0 0 10px #fff;">0</div>
            </div>
            
            <div style="text-align:center; border-top:1px solid #333; padding-top:15px; width:100%;">
                <p style="color:#888; font-size:12px; letter-spacing:2px; margin-bottom:5px;">HIGH SCORE RECORD</p>
                <div id="high-score-display" style="font-size:32px; color:var(--warning); font-weight:700; line-height:1; text-shadow:0 0 10px var(--warning);">0</div>
            </div>
        </div>

        <button id="btn-retry" class="btn">REBOOT SYSTEM</button>
    </div>

    <!-- HUD -->
    <div id="ui-layer">
        <div id="score-box" class="hud-panel"><span class="label">SCORE</span><span id="ui-score" class="value">0</span></div>
        <div id="wave-box" class="hud-panel"><span class="label">THREAT LEVEL</span><span id="ui-wave" class="value">WAVE 1</span></div>
        <div id="alert-msg">WARNING: OVERHEAT</div>
        <div id="heat-container"><span class="label" style="color:#fff; font-size:10px;">CORE TEMPERATURE</span><div class="heat-bar-bg"><div id="heat-fill"></div></div></div>
        <div id="emp-btn"><div style="font-size:10px;">EMP</div><div id="ui-emp-val" style="font-size:16px;">0%</div></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- 堅牢なオーディオシステム ---
        const AudioSys = {
            ctx: null, ready: false,
            init: function() {
                try {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    if (!AC) return; 
                    if (!this.ctx) this.ctx = new AC();
                    this.ready = true;
                    if(this.ctx.state === 'suspended') {
                        this.ctx.resume().catch(e => console.log("Audio resume failed, but game continues."));
                    }
                } catch(e) { console.warn("Audio Init Warning (Ignored)"); }
            },
            playTone: function(type, freq, dur, vol) {
                if(!this.ready || !this.ctx) return;
                try {
                    const t = this.ctx.currentTime;
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = type; osc.frequency.setValueAtTime(freq, t);
                    osc.frequency.exponentialRampToValueAtTime(freq*0.5, t + dur);
                    gain.gain.setValueAtTime(vol, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + dur);
                    osc.connect(gain).connect(this.ctx.destination);
                    osc.start(t); osc.stop(t + dur);
                } catch(e) {}
            },
            playNoise: function(dur) {
                if(!this.ready || !this.ctx) return;
                try {
                    const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * dur, this.ctx.sampleRate);
                    const data = buf.getChannelData(0);
                    for(let i=0; i<data.length; i++) data[i] = Math.random()*2-1;
                    const src = this.ctx.createBufferSource();
                    src.buffer = buf;
                    const gain = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass'; filter.frequency.value = 800;
                    gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
                    src.connect(filter).connect(gain).connect(this.ctx.destination);
                    src.start();
                } catch(e) {}
            },
            shoot: function() { this.playTone('sawtooth', 800, 0.1, 0.08); },
            hit: function() { this.playTone('square', 200, 0.1, 0.05); },
            explode: function() { this.playNoise(0.4); },
            emp: function() { this.playTone('sine', 150, 1.5, 0.3); this.playNoise(1.0); }
        };

        // --- ゲームエンジン ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        // DOM Elements
        const uiLayer = document.getElementById('ui-layer');
        const screenStart = document.getElementById('screen-start');
        const screenOver = document.getElementById('screen-over');
        const uiScore = document.getElementById('ui-score');
        const uiWave = document.getElementById('ui-wave');
        const uiHeat = document.getElementById('heat-fill');
        const uiAlert = document.getElementById('alert-msg');
        const uiEmpVal = document.getElementById('ui-emp-val');
        const btnEmp = document.getElementById('emp-btn');
        const btnStart = document.getElementById('btn-start');
        const btnRetry = document.getElementById('btn-retry');

        // State
        let width, height, cx, cy;
        let logicalWidth, logicalHeight; // ゲーム内の論理サイズ
        let zoomScale = 1.0; // 描画時のスケール係数

        let gameState = 'MENU';
        let frame = 0;
        let score = 0, wave = 1;
        let heat = 0, shield = 100, emp = 0;
        let isOverheated = false;
        let shake = 0;
        let gridOffset = 0;

        // Entities
        let enemies = [], bullets = [], particles = [], texts = [];
        let matrixRain = [];

        // Colors
        const GameColors = {
            main: '#00ffcc', warn: '#ffcc00', danger: '#ff3366',
            bug: '#0f0', virus: '#f0f', worm: '#ff0'
        };

        // --- 初期化 ---
        function resize() {
            // 実際のウィンドウサイズ
            const realWidth = window.innerWidth;
            const realHeight = window.innerHeight;
            
            // Canvasは実サイズに合わせる（高解像度維持）
            canvas.width = realWidth;
            canvas.height = realHeight;

            // スマホ（幅が狭い）の場合はズームアウト（視野を広げる）
            // 0.6倍で描画することで、実質的に画面が1.66倍広くなったように見せる
            if (realWidth < 768) {
                zoomScale = 0.65; // スマホ用ズームアウト率
            } else {
                zoomScale = 1.0;  // PC等はそのまま
            }

            // ゲーム内の論理的な画面サイズ
            logicalWidth = realWidth / zoomScale;
            logicalHeight = realHeight / zoomScale;
            
            cx = logicalWidth / 2;
            cy = logicalHeight / 2;

            initMatrixRain();
        }
        
        function initMatrixRain() {
            matrixRain = [];
            // 論理幅に基づいて列を作る
            const cols = Math.ceil(logicalWidth / 20);
            for(let i=0; i<cols; i++) {
                matrixRain.push({
                    x: i * 20,
                    y: Math.random() * logicalHeight,
                    speed: Math.random() * 3 + 2,
                    chars: [],
                    len: Math.floor(Math.random() * 15 + 5)
                });
            }
        }
        window.addEventListener('resize', resize);
        resize();

        // --- iOS Safari ズーム防止 ---
        document.addEventListener('gesturestart', function(e) {
            e.preventDefault();
        });

        // --- メインループ ---
        function loop() {
            requestAnimationFrame(loop);
            frame++;

            // 描画設定の保存
            ctx.save();
            
            // 全体をズームアウト（縮小）して描画
            ctx.scale(zoomScale, zoomScale);

            // 背景描画（論理サイズで塗りつぶし）
            ctx.fillStyle = 'rgba(5, 5, 8, 0.4)'; 
            ctx.fillRect(0, 0, logicalWidth, logicalHeight);

            // カメラシェイク
            if(shake > 0) {
                ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
                shake *= 0.9;
                if(shake < 0.5) shake = 0;
            }

            drawMatrixRain();
            drawGrid();

            ctx.globalCompositeOperation = 'lighter'; 

            if (gameState === 'PLAY') {
                updateGame();
                drawGameEntities();
            } else if (gameState === 'MENU') {
                drawParticles();
                drawCore(cx, cy); 
            } else if (gameState === 'OVER') {
                updateParticles();
                drawGameEntities(); 
            }

            ctx.globalCompositeOperation = 'source-over';
            
            // HUD描画はHTMLレイヤーで行うが、Canvas内テキストなどはここで
            if(gameState === 'PLAY') {
                drawFloatingTexts();
                drawDamageOverlay();
            }

            // 描画設定の復元
            ctx.restore();
        }

        // --- 描画関数 (width/height は logicalWidth/logicalHeight を使用) ---
        function drawMatrixRain() {
            ctx.fillStyle = 'rgba(0, 255, 100, 0.15)';
            ctx.font = '14px monospace';
            matrixRain.forEach(col => {
                if (frame % 2 === 0) {
                    col.y += col.speed;
                    if(col.y > logicalHeight + 100) col.y = -50;
                }
                ctx.fillStyle = 'rgba(200, 255, 200, 0.6)'; 
                ctx.fillText(String.fromCharCode(0x30A0 + Math.random()*96), col.x, col.y);
                ctx.fillStyle = 'rgba(0, 255, 100, 0.15)'; 
                for(let k=1; k<5; k++) ctx.fillText(String.fromCharCode(0x30A0 + Math.random()*96), col.x, col.y - k*14);
            });
        }

        function drawGrid() {
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(0, 100, 255, 0.15)';
            gridOffset = (gridOffset + 1.5) % 100;
            ctx.beginPath();
            for(let i=0; i<=logicalWidth; i+=100) { ctx.moveTo(cx, cy); ctx.lineTo(i, logicalHeight); ctx.moveTo(cx, cy); ctx.lineTo(i, 0); }
            for(let i=0; i<logicalHeight/2; i+=40) {
                let y = (i + gridOffset) * (i/200 + 0.5);
                if(y > logicalHeight) continue;
                ctx.moveTo(0, cy + y); ctx.lineTo(logicalWidth, cy + y); ctx.moveTo(0, cy - y); ctx.lineTo(logicalWidth, cy - y);
            }
            ctx.stroke();
        }

        function drawGameEntities() {
            ctx.fillStyle = '#fff';
            bullets.forEach(b => {
                ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.moveTo(b.x, b.y); ctx.lineTo(b.x - b.vx*1.5, b.y - b.vy*1.5);
                ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.stroke();
            });

            enemies.forEach(e => {
                ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle);
                let c = e.flash > 0 ? '#fff' : e.color;
                ctx.strokeStyle = c; ctx.fillStyle = c; ctx.shadowBlur = 10; ctx.shadowColor = c; ctx.lineWidth = 2;

                if(e.type === 'bug') {
                    ctx.save(); ctx.rotate(e.rot); ctx.beginPath();
                    for(let k=0; k<6; k++) ctx.lineTo(Math.cos(k*Math.PI/3)*18, Math.sin(k*Math.PI/3)*18);
                    ctx.closePath(); ctx.stroke(); ctx.restore();
                } else if(e.type === 'virus') {
                    ctx.beginPath();
                    for(let k=0; k<12; k++) { let r=k%2==0?22:12; ctx.lineTo(Math.cos(k*Math.PI/6+e.rot)*r, Math.sin(k*Math.PI/6+e.rot)*r); }
                    ctx.closePath(); ctx.stroke(); ctx.fill();
                } else {
                    ctx.beginPath(); ctx.moveTo(15,0); ctx.lineTo(-10,10); ctx.lineTo(-10,-10); ctx.fill();
                }
                ctx.restore();
            });

            drawParticles();
            drawCore(cx, cy);
        }

        function drawCore(x, y) {
            // シールドゲージ
            const maxRadius = 52;
            const shieldPct = Math.max(0, shield / 100);
            
            ctx.save();
            ctx.translate(x, y);
            
            ctx.beginPath();
            ctx.arc(0, 0, maxRadius, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 4;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(0, 0, maxRadius, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * shieldPct));
            
            let barColor = GameColors.main;
            if(shield < 30) barColor = GameColors.danger;
            else if(shield < 60) barColor = GameColors.warn;
            
            ctx.strokeStyle = barColor;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.shadowColor = barColor;
            ctx.shadowBlur = 15;
            ctx.stroke();
            
            ctx.restore();

            // 本体
            ctx.shadowBlur = 20; ctx.shadowColor = isOverheated ? GameColors.danger : GameColors.main;
            ctx.strokeStyle = isOverheated ? GameColors.danger : GameColors.main; ctx.lineWidth = 2;
            ctx.save(); ctx.translate(x, y);
            ctx.rotate(frame * 0.02); ctx.beginPath(); ctx.arc(0, 0, 35, 0, Math.PI*1.5); ctx.stroke();
            ctx.rotate(frame * -0.05); ctx.beginPath(); ctx.arc(0, 0, 42, 0, Math.PI); ctx.stroke();
            ctx.fillStyle = isOverheated ? '#f00' : '#0ff'; ctx.beginPath(); ctx.arc(0, 0, 15 + Math.sin(frame*0.2)*3, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.save(); ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
                if(p.type === 'shockwave') {
                    ctx.strokeStyle = p.color; ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.stroke(); p.size += 5;
                } else {
                    ctx.translate(p.x, p.y); if(p.type === 'debris') ctx.rotate(p.rot);
                    ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                }
                ctx.restore();
            });
        }

        function drawFloatingTexts() {
            ctx.font = 'bold 20px "Share Tech Mono"'; ctx.textAlign = 'center';
            texts.forEach(t => {
                ctx.fillStyle = `rgba(255,255,255,${t.life})`;
                ctx.fillText(t.text, t.x, t.y);
            });
        }

        function drawDamageOverlay() {
            if (shield < 30 && frame % 10 < 5) {
                const grad = ctx.createRadialGradient(cx, cy, logicalHeight*0.4, cx, cy, logicalHeight);
                grad.addColorStop(0.5, 'transparent'); grad.addColorStop(1, 'rgba(255,0,0,0.5)');
                ctx.fillStyle = grad; ctx.fillRect(0,0,logicalWidth,logicalHeight);
            }
        }

        // --- ゲーム更新 ---
        function updateGame() {
            const spawnRate = Math.max(15, 90 - wave * 5);
            if (frame % spawnRate === 0) spawnEnemy();

            if (isOverheated) {
                heat -= 0.4; if(heat <= 0) { heat = 0; isOverheated = false; uiAlert.style.display = 'none'; }
            } else {
                heat = Math.max(0, heat - 0.2);
            }

            emp = Math.min(100, emp + 0.04);

            for(let i=bullets.length-1; i>=0; i--) {
                let b = bullets[i]; b.x += b.vx; b.y += b.vy;
                if(b.x < -50 || b.x > logicalWidth+50 || b.y < -50 || b.y > logicalHeight+50) bullets.splice(i,1);
            }

            for(let i=enemies.length-1; i>=0; i--) {
                let e = enemies[i];
                let angle = Math.atan2(cy - e.y, cx - e.x);
                if(e.type === 'worm') {
                    e.x += Math.cos(angle + Math.sin(frame*0.2)*0.8) * e.speed;
                    e.y += Math.sin(angle + Math.sin(frame*0.2)*0.8) * e.speed;
                } else {
                    e.x += Math.cos(angle) * e.speed;
                    e.y += Math.sin(angle) * e.speed;
                }
                e.angle = angle; e.rot += e.rotSpeed;

                if(Math.hypot(cx - e.x, cy - e.y) < 30) {
                    takeDamage(15); createExplosion(e.x, e.y, e.color); enemies.splice(i,1);
                    AudioSys.hit(); continue;
                }

                for(let j=bullets.length-1; j>=0; j--) {
                    let b = bullets[j];
                    if(Math.hypot(b.x - e.x, b.y - e.y) < e.size + 15) {
                        e.hp--; bullets.splice(j,1); createSpark(b.x, b.y, '#fff', 3);
                        if(e.hp <= 0) { killEnemy(e); enemies.splice(i,1); }
                        else { e.flash = 4; AudioSys.hit(); }
                        break;
                    }
                }
                if(e.flash > 0) e.flash--;
            }
            updateParticles();
            updateUI();
        }

        function updateParticles() {
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= p.decay;
                if(p.type === 'debris') p.rot += 0.1;
                if(p.life <= 0) particles.splice(i,1);
            }
            for(let i=texts.length-1; i>=0; i--) {
                texts[i].y -= 1; texts[i].life -= 0.02;
                if(texts[i].life <= 0) texts.splice(i,1);
            }
        }

        // --- アクション ---
        function spawnEnemy() {
            let angle = Math.random() * Math.PI * 2;
            let dist = Math.max(logicalWidth, logicalHeight) / 2 + 60; // 論理サイズを使用
            let rand = Math.random();
            let type = 'bug'; let hp = 1; let speed = 2 + (wave * 0.1); let color = GameColors.bug; let size = 15; let scoreVal = 100;
            if (score > 500 && rand < 0.25) { type = 'virus'; hp = 4; speed *= 0.7; color = GameColors.virus; size = 20; scoreVal = 300; }
            else if (score > 1000 && rand < 0.15) { type = 'worm'; hp = 2; speed *= 1.5; color = GameColors.worm; size = 15; scoreVal = 200; }
            enemies.push({ x: cx + Math.cos(angle)*dist, y: cy + Math.sin(angle)*dist, type, hp, maxHp: hp, speed, color, size, angle: 0, rot: 0, rotSpeed: (Math.random()-0.5)*0.2, flash: 0, score: scoreVal });
        }

        function shoot(tx, ty) {
            // 入力座標をズームスケールで補正して論理座標に変換
            let lx = tx / zoomScale;
            let ly = ty / zoomScale;

            if (isOverheated || gameState !== 'PLAY') return;
            let angle = Math.atan2(ly - cy, lx - cx);
            bullets.push({ x: cx, y: cy, vx: Math.cos(angle)*22, vy: Math.sin(angle)*22 });
            createSpark(cx + Math.cos(angle)*20, cy + Math.sin(angle)*20, GameColors.main, 5);
            heat += 6; if(heat >= 100) { heat = 100; isOverheated = true; uiAlert.style.display = 'block'; }
            shake = 3; AudioSys.shoot();
        }

        function killEnemy(e) {
            score += e.score; emp = Math.min(100, emp + 6);
            createExplosion(e.x, e.y, e.color); spawnText(e.score, e.x, e.y);
            shake = 5; AudioSys.explode();
        }

        function takeDamage(amount) {
            shield -= amount; shake = 15;
            
            if(shield <= 0) {
                shield = 0;
                gameOver();
                return;
            }

            let div = document.createElement('div');
            div.style.cssText = "position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(255,0,0,0.4);z-index:90;";
            document.body.appendChild(div); setTimeout(()=>div.remove(), 100);
        }

        function triggerEMP() {
            if(emp < 100) return;
            emp = 0;
            enemies.forEach(e => { createExplosion(e.x, e.y, e.color); score += e.score; });
            enemies = []; shake = 30;
            let div = document.createElement('div');
            div.style.cssText = "position:fixed;top:0;left:0;width:100%;height:100%;background:#fff;z-index:99;transition:opacity 0.5s;";
            document.body.appendChild(div); setTimeout(()=>{ div.style.opacity=0; setTimeout(()=>div.remove(),500); }, 50);
            AudioSys.emp();
        }

        function createExplosion(x, y, c) {
            particles.push({ type:'shockwave', x, y, size:10, life:1, decay:0.06, color:c, vx:0, vy:0 });
            for(let i=0; i<8; i++) particles.push({ type:'debris', x, y, size: Math.random()*8+4, vx:(Math.random()-0.5)*12, vy:(Math.random()-0.5)*12, life:1, decay:0.04, color:c, rot:0 });
            for(let i=0; i<10; i++) particles.push({ type:'spark', x, y, size:2, vx:(Math.random()-0.5)*15, vy:(Math.random()-0.5)*15, life:0.6, decay:0.08, color:c });
        }
        function createSpark(x, y, c, count) {
            for(let i=0; i<count; i++) particles.push({ type:'spark', x, y, size:2, vx:(Math.random()-0.5)*8, vy:(Math.random()-0.5)*8, life:0.4, decay:0.1, color:c });
        }
        function spawnText(str, x, y) { texts.push({ text: str, x: x, y: y, life: 1.0 }); }

        function updateUI() {
            uiScore.innerText = score;
            uiWave.innerText = "WAVE " + (1 + Math.floor(score/1500));
            uiHeat.style.width = heat + "%";
            uiEmpVal.innerText = Math.floor(emp) + "%";
            if(emp >= 100) { btnEmp.classList.add('ready'); uiEmpVal.innerText = "READY"; }
            else { btnEmp.classList.remove('ready'); }
        }

        // --- イベント制御 ---
        let gameStarted = false;

        function startGame(e) {
            if(e && e.cancelable) e.preventDefault();
            if(e) e.stopPropagation();

            if (gameStarted) return;
            gameStarted = true;

            AudioSys.init(); 

            gameState = 'PLAY';
            score = 0; wave = 1; heat = 0; shield = 100; emp = 0;
            enemies = []; bullets = []; particles = []; texts = [];
            isOverheated = false;

            screenStart.style.display = 'none';
            screenOver.style.display = 'none';
            uiLayer.style.display = 'block';
            uiAlert.style.display = 'none';
        }

        function gameOver() {
            gameState = 'OVER';
            uiLayer.style.display = 'none';
            screenOver.style.display = 'flex';
            
            let highScore = parseInt(localStorage.getItem('matrix_high_score')) || 0;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('matrix_high_score', highScore);
            }

            document.getElementById('final-score').innerText = score;
            document.getElementById('high-score-display').innerText = highScore;
            
            gameStarted = false; 
        }

        function retryGame(e) {
            if(e && e.cancelable) e.preventDefault();
            if(e) e.stopPropagation();
            gameStarted = false; 
            startGame(e);
        }

        btnStart.addEventListener('touchstart', startGame, {passive: false});
        btnStart.addEventListener('click', startGame);

        btnRetry.addEventListener('touchstart', retryGame, {passive: false});
        btnRetry.addEventListener('click', retryGame);

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            if(gameState !== 'PLAY') return;
            for(let i=0; i<e.touches.length; i++) {
                shoot(e.touches[i].clientX, e.touches[i].clientY);
            }
        }, {passive: false});

        canvas.addEventListener('mousedown', (e) => {
            if(gameState !== 'PLAY') return;
            shoot(e.clientX, e.clientY);
        });

        btnEmp.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); triggerEMP(); }, {passive: false});
        btnEmp.addEventListener('mousedown', (e) => { e.stopPropagation(); triggerEMP(); });

        loop();

    </script>
</body>
</html>
