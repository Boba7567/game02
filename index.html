<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <!-- Viewportを標準の1.0に戻して、UIのサイズ感を適正化 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>MATRIX DEFENDER: ABSOLUTE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&family=Share+Tech+Mono&display=swap');

        :root {
            --primary: #00ffcc;
            --secondary: #0088ff;
            --danger: #ff3366;
            --warning: #ffcc00;
            --heal: #00ffff;
            --bg: #050505;
        }

        html, body {
            width: 100%; height: 100%;
            margin: 0; padding: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Rajdhani', sans-serif;
            color: var(--primary);
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            position: fixed;
        }

        .vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 40%, rgba(0,0,0,0.9) 100%);
            pointer-events: none; z-index: 10;
        }
        .scanlines {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.1) 0px, rgba(0,0,0,0.1) 1px, transparent 1px, transparent 2px);
            pointer-events: none; z-index: 11;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 20; display: none;
        }

        .hud-panel {
            position: absolute;
            background: rgba(0, 20, 40, 0.7);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(0, 255, 204, 0.3);
            padding: 3px 10px;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.1);
        }
        .hud-panel::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary), transparent);
        }

        #score-box { top: 10px; left: 10px; }
        .label { font-family: 'Share Tech Mono'; font-size: 10px; letter-spacing: 1px; color: var(--secondary); display: block; margin-bottom: -2px; }
        .value { font-size: 24px; font-weight: 700; line-height: 1.1; text-shadow: 0 0 10px var(--primary); }

        #wave-box { top: 10px; right: 10px; text-align: right; border-color: var(--warning); }
        #wave-box .label { color: var(--warning); }
        #ui-wave { color: var(--warning); text-shadow: 0 0 10px var(--warning); }

        #heat-container {
            position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);
            width: 160px; text-align: center;
        }
        .heat-bar-bg {
            width: 100%; height: 6px; background: rgba(255,255,255,0.1);
            border-radius: 3px; overflow: hidden; margin-top: 3px;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #heat-fill {
            width: 0%; height: 100%; 
            background: linear-gradient(90deg, var(--secondary), var(--warning), var(--danger));
            transition: width 0.1s linear;
            box-shadow: 0 0 10px var(--danger);
        }

        #emp-btn {
            position: absolute; bottom: 30px; right: 15px;
            width: 70px; height: 70px;
            border-radius: 50%;
            background: rgba(0, 10, 0, 0.6);
            border: 2px solid rgba(255,255,255,0.1);
            pointer-events: auto;
            display: flex; align-items: center; justify-content: center; flex-direction: column;
            color: rgba(255,255,255,0.3); font-size: 10px; font-weight: bold;
            transition: all 0.3s; cursor: pointer;
            backdrop-filter: blur(5px);
            touch-action: manipulation;
        }
        #emp-btn.ready {
            border-color: var(--secondary); color: #000; background: var(--secondary);
            box-shadow: 0 0 20px var(--secondary), inset 0 0 10px rgba(255,255,255,0.5);
            animation: pulse-btn 1s infinite alternate;
        }
        #emp-btn:active { transform: scale(0.95); }

        #alert-msg {
            position: absolute; top: 40%; width: 100%; text-align: center; font-size: 24px;
            color: var(--danger); font-weight: 700; text-shadow: 0 0 20px var(--danger);
            display: none; letter-spacing: 3px; animation: flash-text 0.15s infinite;
            background: rgba(0,0,0,0.3); padding: 5px 0;
        }

        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(3, 3, 5, 0.9);
            backdrop-filter: blur(10px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; pointer-events: auto;
            padding: 20px; box-sizing: border-box;
        }
        h1.title {
            font-size: clamp(32px, 10vw, 80px);
            margin: 0 0 20px 0; text-align: center; line-height: 0.9;
            background: linear-gradient(to bottom, #fff, var(--primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px var(--primary)); letter-spacing: 3px;
            width: 100%; word-break: break-word;
        }
        
        .btn {
            background: rgba(0,0,0,0.5); color: #fff;
            border: 2px solid var(--primary);
            padding: 15px 40px;
            font-size: 20px;
            font-family: 'Share Tech Mono'; letter-spacing: 2px;
            cursor: pointer; text-transform: uppercase;
            position: relative; overflow: hidden;
            transition: 0.2s;
            box-shadow: 0 0 15px rgba(0,255,204,0.2);
            touch-action: manipulation;
            user-select: none;
            z-index: 101;
            white-space: nowrap;
            margin-bottom: 15px; 
        }
        .btn:active { background: var(--primary); color: #000; transform: scale(0.96); }

        .btn-sub {
            background: transparent; color: rgba(255,255,255,0.7);
            border: 1px solid rgba(255,255,255,0.3);
            font-size: 14px; padding: 10px 20px;
        }
        .btn-sub:active { background: rgba(255,255,255,0.2); }

        #screen-tips {
            align-items: flex-start; 
            padding-top: 40px;
            background: rgba(0, 10, 20, 0.95);
        }
        
        .tips-container {
            width: 100%; max-width: 400px;
            margin-bottom: 20px;
            flex-grow: 1; 
            overflow-y: auto; 
            -webkit-overflow-scrolling: touch;
            padding-right: 5px;
        }
        
        .tips-section {
            margin-bottom: 25px;
            border-left: 2px solid var(--primary);
            padding-left: 15px;
        }
        
        .tips-head {
            color: var(--primary); font-size: 16px; font-weight: bold;
            border-bottom: 1px solid rgba(0, 255, 204, 0.2);
            margin-bottom: 10px; padding-bottom: 5px; letter-spacing: 1px;
        }

        .tips-row { display: flex; align-items: center; margin-bottom: 8px; font-size: 13px; color: #ccc; }
        .key-icon {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 2px 6px; border-radius: 3px;
            color: #fff; font-family: 'Share Tech Mono'; margin-right: 10px;
            font-size: 11px; min-width: 50px; text-align: center; flex-shrink: 0;
        }
        .hl-warn { color: var(--danger); font-weight: bold; }
        .hl-emp { color: var(--secondary); font-weight: bold; }
        .hl-heal { color: var(--heal); font-weight: bold; }

        @keyframes pulse-btn { from { box-shadow: 0 0 15px var(--secondary); } to { box-shadow: 0 0 30px var(--secondary); } }
        @keyframes flash-text { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
    </style>
</head>
<body>

    <div class="vignette"></div>
    <div class="scanlines"></div>

    <!-- スタート画面 -->
    <div id="screen-start" class="screen">
        <h1 class="title">MATRIX<br>DEFENDER<br><span style="font-size:0.5em; letter-spacing:5px; color:var(--secondary)">ABSOLUTE</span></h1>
        
        <button id="btn-start" class="btn">SYSTEM BOOT</button>
        <button id="btn-tips" class="btn btn-sub" style="margin-top:10px;">MISSION DATA</button>
        
        <div style="font-size:12px; color:#555; margin-top:30px; letter-spacing:1px;">TOUCH INTERFACE READY</div>
    </div>

    <!-- TIPS画面 -->
    <div id="screen-tips" class="screen" style="display:none;">
        <h2 style="color:#fff; margin-bottom:20px; letter-spacing:2px; border-bottom:2px solid var(--primary);">DATABASE</h2>
        
        <div class="tips-container">
            <div class="tips-section">
                <div class="tips-head">BASIC OPERATIONS</div>
                <div class="tips-row"><span class="key-icon">TAP</span><span>画面タップで迎撃ビーム発射</span></div>
                <div class="tips-row"><span class="key-icon" style="color:var(--danger); border-color:var(--danger);">HEAT</span><span>連射しすぎると<span class="hl-warn">オーバーヒート</span></span></div>
                <div class="tips-row"><span class="key-icon" style="color:var(--secondary); border-color:var(--secondary);">EMP</span><span>ゲージMAXで<span class="hl-emp">全画面攻撃</span></span></div>
            </div>

            <div class="tips-section">
                <div class="tips-head" style="color:var(--secondary); border-color:var(--secondary);">ENEMY INTEL</div>
                <div class="tips-row"><span class="key-icon" style="color:#0f0; border-color:rgba(0,255,0,0.4);">BUG</span><span>標準型。数で攻めてくる。</span></div>
                <div class="tips-row"><span class="key-icon" style="color:#f0f; border-color:rgba(255,0,255,0.4);">VIRUS</span><span>高耐久。破壊には連射が必要。</span></div>
                <div class="tips-row"><span class="key-icon" style="color:#ff0; border-color:rgba(255,255,0,0.4);">WORM</span><span>予測不能な蛇行軌道で接近。</span></div>
                <div class="tips-row"><span class="key-icon" style="color:#f80; border-color:rgba(255,128,0,0.4);">TANK</span><span>超重装甲。極めて硬いが遅い。</span></div>
                <div class="tips-row"><span class="key-icon" style="color:#ddd; border-color:rgba(221,221,221,0.4);">GHOST</span><span>ステルス機能搭載。<span class="hl-warn">視認困難</span>。</span></div>
                <div class="tips-row"><span class="key-icon" style="color:var(--heal); border-color:rgba(0,255,255,0.4);">NANO</span><span>補給機。<span class="hl-heal">撃破でシールド回復</span>。</span></div>
            </div>
        </div>

        <button id="btn-back" class="btn btn-sub" style="width:100%; max-width:300px;">CLOSE DATABASE</button>
    </div>

    <!-- ゲームオーバー画面 -->
    <div id="screen-over" class="screen" style="display:none;">
        <h1 class="title" style="background:linear-gradient(to bottom, #fff, var(--danger)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; filter:drop-shadow(0 0 20px var(--danger));">CRITICAL<br>ERROR</h1>
        <div style="display:flex; flex-direction:column; align-items:center; gap:20px; margin-bottom:40px;">
            <div style="text-align:center;">
                <p style="color:#aaa; font-size:14px; letter-spacing:2px; margin-bottom:5px;">FINAL SCORE</p>
                <div id="final-score" style="font-size:52px; color:#fff; font-weight:700; line-height:1; text-shadow:0 0 10px #fff;">0</div>
            </div>
            <div style="text-align:center; border-top:1px solid #333; padding-top:15px; width:100%;">
                <p style="color:#888; font-size:12px; letter-spacing:2px; margin-bottom:5px;">HIGH SCORE RECORD</p>
                <div id="high-score-display" style="font-size:32px; color:var(--warning); font-weight:700; line-height:1; text-shadow:0 0 10px var(--warning);">0</div>
            </div>
        </div>
        <button id="btn-retry" class="btn">REBOOT SYSTEM</button>
    </div>

    <!-- HUD -->
    <div id="ui-layer">
        <div id="score-box" class="hud-panel"><span class="label">SCORE</span><span id="ui-score" class="value">0</span></div>
        <div id="wave-box" class="hud-panel"><span class="label">THREAT LEVEL</span><span id="ui-wave" class="value">WAVE 1</span></div>
        <div id="alert-msg">WARNING: OVERHEAT</div>
        <div id="heat-container"><span class="label" style="color:#fff; font-size:10px;">CORE TEMPERATURE</span><div class="heat-bar-bg"><div id="heat-fill"></div></div></div>
        <div id="emp-btn"><div style="font-size:10px;">EMP</div><div id="ui-emp-val" style="font-size:16px;">0%</div></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const AudioSys = {
            ctx: null, ready: false,
            init: function() {
                try {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    if (!AC) return; 
                    if (!this.ctx) this.ctx = new AC();
                    this.ready = true;
                    if(this.ctx.state === 'suspended') { this.ctx.resume().catch(e => {}); }
                } catch(e) {}
            },
            playTone: function(type, freq, dur, vol) {
                if(!this.ready || !this.ctx) return;
                try {
                    const t = this.ctx.currentTime;
                    const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                    osc.type = type; osc.frequency.setValueAtTime(freq, t);
                    osc.frequency.exponentialRampToValueAtTime(freq*0.5, t + dur);
                    gain.gain.setValueAtTime(vol, t); gain.gain.exponentialRampToValueAtTime(0.001, t + dur);
                    osc.connect(gain).connect(this.ctx.destination);
                    osc.start(t); osc.stop(t + dur);
                } catch(e) {}
            },
            playNoise: function(dur) {
                if(!this.ready || !this.ctx) return;
                try {
                    const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * dur, this.ctx.sampleRate);
                    const data = buf.getChannelData(0);
                    for(let i=0; i<data.length; i++) data[i] = Math.random()*2-1;
                    const src = this.ctx.createBufferSource(); src.buffer = buf;
                    const gain = this.ctx.createGain(); const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass'; filter.frequency.value = 800;
                    gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
                    src.connect(filter).connect(gain).connect(this.ctx.destination); src.start();
                } catch(e) {}
            },
            shoot: function() { this.playTone('sawtooth', 800, 0.1, 0.08); },
            hit: function() { this.playTone('square', 200, 0.1, 0.05); },
            explode: function() { this.playNoise(0.4); },
            emp: function() { this.playTone('sine', 150, 1.5, 0.3); this.playNoise(1.0); },
            heal: function() { this.playTone('sine', 600, 0.4, 0.15); } 
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        const uiLayer = document.getElementById('ui-layer');
        const screenStart = document.getElementById('screen-start');
        const screenTips = document.getElementById('screen-tips');
        const screenOver = document.getElementById('screen-over');
        const uiScore = document.getElementById('ui-score');
        const uiWave = document.getElementById('ui-wave');
        const uiHeat = document.getElementById('heat-fill');
        const uiAlert = document.getElementById('alert-msg');
        const uiEmpVal = document.getElementById('ui-emp-val');
        const btnEmp = document.getElementById('emp-btn');
        const btnStart = document.getElementById('btn-start');
        const btnTips = document.getElementById('btn-tips');
        const btnBack = document.getElementById('btn-back');
        const btnRetry = document.getElementById('btn-retry');

        let width, height, cx, cy;
        let logicalWidth, logicalHeight;
        let zoomScale = 1.0;

        let gameState = 'MENU';
        let frame = 0;
        let score = 0, wave = 1;
        let heat = 0, shield = 100, emp = 0;
        let isOverheated = false;
        let shake = 0;
        let gridOffset = 0;

        let enemies = [], bullets = [], particles = [], texts = [];
        let matrixRain = [];

        const GameColors = {
            main: '#00ffcc', warn: '#ffcc00', danger: '#ff3366',
            bug: '#0f0', virus: '#f0f', worm: '#ff0',
            tank: '#f80', ghost: '#ddd', nano: '#00ffff'
        };

        function resize() {
            const realWidth = window.innerWidth;
            const realHeight = window.innerHeight;
            canvas.width = realWidth;
            canvas.height = realHeight;

            // スマホ向けにCanvasの描画領域だけをズームアウトさせる
            if (realWidth < 768) { 
                zoomScale = 0.5; // 0.6から0.5に変更してさらに視野を広げる
            } else { 
                zoomScale = 1.0; 
            }

            logicalWidth = realWidth / zoomScale;
            logicalHeight = realHeight / zoomScale;
            cx = logicalWidth / 2;
            cy = logicalHeight / 2;

            initMatrixRain();
        }
        
        function initMatrixRain() {
            matrixRain = [];
            const cols = Math.ceil(logicalWidth / 20);
            for(let i=0; i<cols; i++) {
                matrixRain.push({
                    x: i * 20,
                    y: Math.random() * logicalHeight,
                    speed: Math.random() * 3 + 2,
                    chars: [],
                    len: Math.floor(Math.random() * 15 + 5)
                });
            }
        }
        window.addEventListener('resize', resize);
        resize();

        document.addEventListener('gesturestart', function(e) { e.preventDefault(); });

        function loop() {
            requestAnimationFrame(loop);
            frame++;

            ctx.save();
            ctx.scale(zoomScale, zoomScale);

            ctx.fillStyle = 'rgba(5, 5, 8, 0.4)'; 
            ctx.fillRect(0, 0, logicalWidth, logicalHeight);

            if(shake > 0) {
                ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
                shake *= 0.9; if(shake < 0.5) shake = 0;
            }

            drawMatrixRain();
            drawGrid();

            ctx.globalCompositeOperation = 'lighter'; 

            if (gameState === 'PLAY') {
                updateGame();
                drawGameEntities();
            } else if (gameState === 'MENU' || gameState === 'TIPS') {
                drawParticles();
                drawCore(cx, cy); 
            } else if (gameState === 'OVER') {
                updateParticles();
                drawGameEntities(); 
            }

            ctx.globalCompositeOperation = 'source-over';
            
            if(gameState === 'PLAY') {
                drawFloatingTexts();
                drawDamageOverlay();
            }

            ctx.restore();
        }

        function drawMatrixRain() {
            ctx.fillStyle = 'rgba(0, 255, 100, 0.1)';
            ctx.font = '14px monospace';
            matrixRain.forEach(col => {
                if (frame % 2 === 0) {
                    col.y += col.speed;
                    if(col.y > logicalHeight + 100) col.y = -50;
                }
                ctx.fillStyle = 'rgba(200, 255, 200, 0.5)'; 
                ctx.fillText(String.fromCharCode(0x30A0 + Math.random()*96), col.x, col.y);
                ctx.fillStyle = 'rgba(0, 255, 100, 0.1)'; 
                for(let k=1; k<5; k++) ctx.fillText(String.fromCharCode(0x30A0 + Math.random()*96), col.x, col.y - k*14);
            });
        }

        function drawGrid() {
            ctx.lineWidth = 1;
            gridOffset = (gridOffset + 1.5) % 100;
            
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0, 100, 255, 0.15)';
            for(let i=0; i<=logicalWidth; i+=100) { ctx.moveTo(cx, cy); ctx.lineTo(i, logicalHeight); ctx.moveTo(cx, cy); ctx.lineTo(i, 0); }
            for(let i=0; i<logicalHeight/2; i+=40) {
                let y = (i + gridOffset) * (i/200 + 0.5);
                if(y > logicalHeight) continue;
                ctx.moveTo(0, cy + y); ctx.lineTo(logicalWidth, cy + y); 
                ctx.moveTo(0, cy - y); ctx.lineTo(logicalWidth, cy - y);
            }
            ctx.stroke();

            ctx.fillStyle = 'rgba(0, 200, 255, 0.5)';
            for(let i=0; i<logicalHeight/2; i+=40) {
                let y = (i + gridOffset) * (i/200 + 0.5);
                if(y > logicalHeight) continue;
                if(frame % 20 === 0) ctx.fillRect(cx - 2, cy + y - 2, 4, 4); 
            }
        }

        function drawGameEntities() {
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 10; ctx.shadowColor = '#fff';
            bullets.forEach(b => {
                ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.moveTo(b.x, b.y); ctx.lineTo(b.x - b.vx*1.5, b.y - b.vy*1.5);
                ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.stroke();
            });
            ctx.shadowBlur = 0;

            enemies.forEach(e => {
                ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle);
                
                let c = e.flash > 0 ? '#fff' : e.color;
                ctx.strokeStyle = c; ctx.fillStyle = c; 
                ctx.shadowBlur = 15; ctx.shadowColor = c; ctx.lineWidth = 2;

                if(e.type === 'bug') {
                    ctx.save(); ctx.rotate(e.rot); ctx.beginPath(); 
                    for(let k=0; k<6; k++) ctx.lineTo(Math.cos(k*Math.PI/3)*22, Math.sin(k*Math.PI/3)*22);
                    ctx.closePath(); ctx.stroke(); 
                    ctx.rotate(-e.rot * 2); ctx.beginPath(); ctx.rect(-10, -10, 20, 20); ctx.stroke();
                    ctx.restore(); ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2); ctx.fill();
                } else if(e.type === 'virus') {
                    let pulse = Math.sin(frame * 0.2) * 5; ctx.beginPath();
                    for(let k=0; k<16; k++) { let r=k%2==0?28+pulse:16; let a=k*Math.PI/8+e.rot; ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r); }
                    ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.fill();
                } else if(e.type === 'tank') {
                    ctx.save(); ctx.rotate(e.rot);
                    ctx.strokeRect(-24, -24, 48, 48); 
                    ctx.fillRect(-14, -14, 28, 28);
                    ctx.restore();
                } else if(e.type === 'ghost') {
                    let alpha = 0.3 + Math.abs(Math.sin(frame * 0.05 + e.id)) * 0.7;
                    ctx.globalAlpha = alpha;
                    ctx.beginPath(); ctx.arc(0, 0, 22, 0, Math.PI * 2); ctx.stroke();
                    ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill();
                    ctx.globalAlpha = 1.0;
                } else if(e.type === 'nano') {
                    ctx.save(); ctx.rotate(e.rot);
                    ctx.beginPath();
                    let s = 1.2;
                    ctx.moveTo(-6*s, -18*s); ctx.lineTo(6*s, -18*s); ctx.lineTo(6*s, -6*s); ctx.lineTo(18*s, -6*s);
                    ctx.lineTo(18*s, 6*s); ctx.lineTo(6*s, 6*s); ctx.lineTo(6*s, 18*s); ctx.lineTo(-6*s, 18*s);
                    ctx.lineTo(-6*s, 6*s); ctx.lineTo(-18*s, 6*s); ctx.lineTo(-18*s, -6*s); ctx.lineTo(-6*s, -6*s);
                    ctx.closePath(); ctx.stroke(); ctx.fill();
                    ctx.restore();
                } else {
                    ctx.beginPath(); ctx.moveTo(18,0); ctx.lineTo(-12,14); ctx.lineTo(-6,0); ctx.lineTo(-12,-14); ctx.fill(); ctx.stroke();
                }
                ctx.restore();
            });

            drawParticles();
            drawCore(cx, cy);
        }

        function drawCore(x, y) {
            const maxRadius = 55;
            const shieldPct = Math.max(0, shield / 100);
            
            ctx.save(); ctx.translate(x, y);
            
            ctx.beginPath(); ctx.arc(0, 0, maxRadius, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; ctx.lineWidth = 4; ctx.setLineDash([2, 4]); ctx.stroke();

            ctx.beginPath(); ctx.arc(0, 0, maxRadius, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * shieldPct));
            let barColor = GameColors.main;
            if(shield < 30) barColor = GameColors.danger; else if(shield < 60) barColor = GameColors.warn;
            ctx.strokeStyle = barColor; ctx.lineWidth = 4; ctx.lineCap = 'round';
            ctx.shadowColor = barColor; ctx.shadowBlur = 15; ctx.stroke(); ctx.setLineDash([]);

            ctx.shadowBlur = 20; ctx.shadowColor = isOverheated ? GameColors.danger : GameColors.main;
            ctx.strokeStyle = isOverheated ? GameColors.danger : GameColors.main; ctx.lineWidth = 2;
            
            ctx.rotate(frame * 0.03); ctx.beginPath(); ctx.arc(0, 0, 32, 0, Math.PI*1.5); ctx.stroke();
            ctx.rotate(frame * -0.06); ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI); ctx.stroke();
            ctx.fillStyle = isOverheated ? '#f00' : '#0ff'; ctx.beginPath(); ctx.arc(0, 0, 15 + Math.sin(frame*0.2)*3, 0, Math.PI*2); ctx.fill();
            
            ctx.restore();
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.save(); ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
                if(p.type === 'shockwave') {
                    ctx.strokeStyle = p.color; ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.stroke(); p.size += 4; 
                } else if(p.type === 'heal_ring') {
                    ctx.strokeStyle = p.color; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.stroke(); p.size += 2;
                } else {
                    ctx.translate(p.x, p.y); if(p.type === 'debris') ctx.rotate(p.rot);
                    ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                }
                ctx.restore();
            });
        }

        function drawFloatingTexts() {
            ctx.font = 'bold 20px "Share Tech Mono"'; ctx.textAlign = 'center';
            texts.forEach(t => {
                ctx.fillStyle = t.color || `rgba(255,255,255,${t.life})`; 
                ctx.fillText(t.text, t.x, t.y);
            });
        }

        function drawDamageOverlay() {
            if (shield < 30 && frame % 10 < 5) {
                const grad = ctx.createRadialGradient(cx, cy, logicalHeight*0.4, cx, cy, logicalHeight);
                grad.addColorStop(0.5, 'transparent'); grad.addColorStop(1, 'rgba(255,0,0,0.5)');
                ctx.fillStyle = grad; ctx.fillRect(0,0,logicalWidth,logicalHeight);
            }
        }

        // --- ゲーム更新 ---
        function updateGame() {
            if (score < 1000) wave = 1;
            else if (score < 3000) wave = 2;
            else if (score < 6000) wave = 3;
            else if (score < 10000) wave = 4;
            else wave = 5; 

            let baseRate = 90 - wave * 10; 
            if (wave >= 5) baseRate = 30; 
            const spawnRate = Math.max(15, baseRate);

            if (frame % spawnRate === 0) spawnEnemy();

            if (isOverheated) { heat -= 0.4; if(heat <= 0) { heat = 0; isOverheated = false; uiAlert.style.display = 'none'; } } 
            else { heat = Math.max(0, heat - 0.2); }

            emp = Math.min(100, emp + 0.04);

            for(let i=bullets.length-1; i>=0; i--) {
                let b = bullets[i]; b.x += b.vx; b.y += b.vy;
                if(b.x < -50 || b.x > logicalWidth+50 || b.y < -50 || b.y > logicalHeight+50) bullets.splice(i,1);
            }

            for(let i=enemies.length-1; i>=0; i--) {
                let e = enemies[i];
                let angle = Math.atan2(cy - e.y, cx - e.x);
                
                if(e.type === 'worm') {
                    e.x += Math.cos(angle + Math.sin(frame*0.2)*0.8) * e.speed;
                    e.y += Math.sin(angle + Math.sin(frame*0.2)*0.8) * e.speed;
                } else if (e.type === 'tank') {
                    e.x += Math.cos(angle) * e.speed;
                    e.y += Math.sin(angle) * e.speed;
                } else if (e.type === 'ghost') {
                    e.x += Math.cos(angle + Math.sin(frame*0.1)*0.5) * e.speed;
                    e.y += Math.sin(angle + Math.sin(frame*0.1)*0.5) * e.speed;
                } else {
                    e.x += Math.cos(angle) * e.speed;
                    e.y += Math.sin(angle) * e.speed;
                }
                
                e.angle = angle; e.rot += e.rotSpeed;

                if(Math.hypot(cx - e.x, cy - e.y) < 30) {
                    if (e.type !== 'nano') {
                        takeDamage(15); 
                    }
                    createExplosion(e.x, e.y, e.color); enemies.splice(i,1);
                    AudioSys.hit(); continue;
                }

                for(let j=bullets.length-1; j>=0; j--) {
                    let b = bullets[j];
                    if(Math.hypot(b.x - e.x, b.y - e.y) < e.size + 15) {
                        e.hp--; bullets.splice(j,1); createSpark(b.x, b.y, '#fff', 3);
                        if(e.hp <= 0) { killEnemy(e); enemies.splice(i,1); }
                        else { e.flash = 4; AudioSys.hit(); }
                        break;
                    }
                }
                if(e.flash > 0) e.flash--;
            }
            updateParticles();
            updateUI();
        }

        function updateParticles() {
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= p.decay;
                if(p.type === 'debris') p.rot += 0.1;
                if(p.life <= 0) particles.splice(i,1);
            }
            for(let i=texts.length-1; i>=0; i--) {
                texts[i].y -= 1; texts[i].life -= 0.02;
                if(texts[i].life <= 0) texts.splice(i,1);
            }
        }

        // --- アクション ---
        function spawnEnemy() {
            let angle = Math.random() * Math.PI * 2;
            let dist = Math.max(logicalWidth, logicalHeight) / 2 + 60;
            let rand = Math.random();
            
            let type = 'bug'; let hp = 1; let speed = 2; let color = GameColors.bug; let size = 18; let scoreVal = 100;
            let rotSpeed = (Math.random()-0.5)*0.2;

            if (rand < 0.05) { // 5%
                type = 'nano'; hp = 1; speed = 3.0; color = GameColors.nano; size = 18; scoreVal = 0; rotSpeed = 0.1;
            } else {
                if (wave >= 5) {
                    speed = 2.5; 
                    if (rand < 0.2) { type = 'tank'; hp = 10; speed = 1.0; color = GameColors.tank; size = 30; scoreVal = 500; rotSpeed = 0.01; }
                    else if (rand < 0.35) { type = 'ghost'; hp = 3; speed = 3.0; color = GameColors.ghost; size = 22; scoreVal = 400; }
                    else if (rand < 0.55) { type = 'virus'; hp = 4; speed = 1.5; color = GameColors.virus; size = 24; scoreVal = 300; }
                    else if (rand < 0.75) { type = 'worm'; hp = 2; speed = 3.5; color = GameColors.worm; size = 18; scoreVal = 200; }
                } 
                else if (wave === 4) {
                    if (rand < 0.1) { type = 'tank'; hp = 10; speed = 0.8; color = GameColors.tank; size = 30; scoreVal = 500; rotSpeed = 0.01; }
                    else if (rand < 0.2) { type = 'ghost'; hp = 3; speed = 2.5; color = GameColors.ghost; size = 22; scoreVal = 400; }
                    else if (rand < 0.4) { type = 'virus'; hp = 4; speed = 1.2; color = GameColors.virus; size = 24; scoreVal = 300; }
                }
                else if (wave === 3) {
                    if (rand < 0.3) { type = 'worm'; hp = 2; speed = 3.0; color = GameColors.worm; size = 18; scoreVal = 200; }
                    else if (rand < 0.5) { type = 'virus'; hp = 4; speed = 1.0; color = GameColors.virus; size = 24; scoreVal = 300; }
                }
                else if (wave === 2) {
                    if (rand < 0.3) { type = 'virus'; hp = 4; speed = 1.0; color = GameColors.virus; size = 24; scoreVal = 300; }
                }
            }

            enemies.push({ x: cx + Math.cos(angle)*dist, y: cy + Math.sin(angle)*dist, type, hp, maxHp: hp, speed, color, size, angle: 0, rot: 0, rotSpeed, flash: 0, score: scoreVal, id: Math.random() });
        }

        function shoot(tx, ty) {
            let lx = tx / zoomScale; let ly = ty / zoomScale;
            if (isOverheated || gameState !== 'PLAY') return;
            let angle = Math.atan2(ly - cy, lx - cx);
            bullets.push({ x: cx, y: cy, vx: Math.cos(angle)*22, vy: Math.sin(angle)*22 });
            createSpark(cx + Math.cos(angle)*20, cy + Math.sin(angle)*20, GameColors.main, 5);
            heat += 6; if(heat >= 100) { heat = 100; isOverheated = true; uiAlert.style.display = 'block'; }
            shake = 3; AudioSys.shoot();
        }

        function killEnemy(e) {
            if (e.type === 'nano') {
                shield = Math.min(100, shield + 20);
                spawnText("REPAIR +20", e.x, e.y, GameColors.nano);
                particles.push({ type:'heal_ring', x:cx, y:cy, size:30, life:1, decay:0.03, color:GameColors.nano, vx:0, vy:0 });
                AudioSys.heal();
            } else {
                score += e.score; emp = Math.min(100, emp + 6);
                spawnText(e.score, e.x, e.y);
                shake = 5; AudioSys.explode();
            }
            createExplosion(e.x, e.y, e.color);
        }

        function takeDamage(amount) {
            shield -= amount; shake = 15;
            if(shield <= 0) { shield = 0; gameOver(); return; }
            let div = document.createElement('div');
            div.style.cssText = "position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(255,0,0,0.4);z-index:90;";
            document.body.appendChild(div); setTimeout(()=>div.remove(), 100);
        }

        function triggerEMP() {
            if(emp < 100) return;
            emp = 0; 
            enemies.forEach(e => { 
                if (e.type !== 'nano') {
                    createExplosion(e.x, e.y, e.color); 
                    score += e.score; 
                }
            }); 
            enemies = []; 
            shake = 30;
            let div = document.createElement('div');
            div.style.cssText = "position:fixed;top:0;left:0;width:100%;height:100%;background:#fff;z-index:99;transition:opacity 0.5s;";
            document.body.appendChild(div); setTimeout(()=>{ div.style.opacity=0; setTimeout(()=>div.remove(),500); }, 50);
            AudioSys.emp();
        }

        function createExplosion(x, y, c) {
            particles.push({ type:'shockwave', x, y, size:10, life:1, decay:0.06, color:c, vx:0, vy:0 });
            for(let i=0; i<8; i++) particles.push({ type:'debris', x, y, size: Math.random()*8+4, vx:(Math.random()-0.5)*12, vy:(Math.random()-0.5)*12, life:1, decay:0.04, color:c, rot:0 });
            for(let i=0; i<10; i++) particles.push({ type:'spark', x, y, size:2, vx:(Math.random()-0.5)*15, vy:(Math.random()-0.5)*15, life:0.6, decay:0.08, color:c });
        }
        function createSpark(x, y, c, count) {
            for(let i=0; i<count; i++) particles.push({ type:'spark', x, y, size:2, vx:(Math.random()-0.5)*8, vy:(Math.random()-0.5)*8, life:0.4, decay:0.1, color:c });
        }
        function spawnText(str, x, y, color) { texts.push({ text: str, x: x, y: y, life: 1.0, color: color }); }

        function updateUI() {
            uiScore.innerText = score;
            let waveText = "WAVE " + wave;
            if (wave >= 5) waveText = "MAX LEVEL";
            uiWave.innerText = waveText;
            uiHeat.style.width = heat + "%";
            uiEmpVal.innerText = Math.floor(emp) + "%";
            if(emp >= 100) { btnEmp.classList.add('ready'); uiEmpVal.innerText = "READY"; } else { btnEmp.classList.remove('ready'); }
        }

        let gameStarted = false;
        function startGame(e) {
            if(e && e.cancelable) e.preventDefault();
            if(e) e.stopPropagation();
            if (gameStarted) return;
            gameStarted = true;
            AudioSys.init(); 
            gameState = 'PLAY'; score = 0; wave = 1; heat = 0; shield = 100; emp = 0;
            enemies = []; bullets = []; particles = []; texts = []; isOverheated = false;
            screenStart.style.display = 'none'; screenOver.style.display = 'none'; screenTips.style.display = 'none';
            uiLayer.style.display = 'block'; uiAlert.style.display = 'none';
        }

        function showTips(e) {
            if(e && e.cancelable) e.preventDefault();
            if(e) e.stopPropagation();
            screenStart.style.display = 'none';
            screenTips.style.display = 'flex';
        }

        function closeTips(e) {
            if(e && e.cancelable) e.preventDefault();
            if(e) e.stopPropagation();
            screenTips.style.display = 'none';
            screenStart.style.display = 'flex';
        }

        function gameOver() {
            gameState = 'OVER'; uiLayer.style.display = 'none'; screenOver.style.display = 'flex';
            let highScore = parseInt(localStorage.getItem('matrix_high_score')) || 0;
            if (score > highScore) { highScore = score; localStorage.setItem('matrix_high_score', highScore); }
            document.getElementById('final-score').innerText = score;
            document.getElementById('high-score-display').innerText = highScore;
            gameStarted = false; 
        }

        function retryGame(e) {
            if(e && e.cancelable) e.preventDefault();
            if(e) e.stopPropagation();
            gameStarted = false; startGame(e);
        }

        btnStart.addEventListener('touchstart', startGame, {passive: false});
        btnStart.addEventListener('click', startGame);
        btnRetry.addEventListener('touchstart', retryGame, {passive: false});
        btnRetry.addEventListener('click', retryGame);
        
        btnTips.addEventListener('touchstart', showTips, {passive: false});
        btnTips.addEventListener('click', showTips);
        btnBack.addEventListener('touchstart', closeTips, {passive: false});
        btnBack.addEventListener('click', closeTips);

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); if(gameState !== 'PLAY') return;
            for(let i=0; i<e.touches.length; i++) { shoot(e.touches[i].clientX, e.touches[i].clientY); }
        }, {passive: false});

        canvas.addEventListener('mousedown', (e) => {
            if(gameState !== 'PLAY') return; shoot(e.clientX, e.clientY);
        });

        btnEmp.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); triggerEMP(); }, {passive: false});
        btnEmp.addEventListener('mousedown', (e) => { e.stopPropagation(); triggerEMP(); });

        loop();
    </script>
</body>
</html>
